## 03 - 2 큐
- 큐는 스택과 마찬가지로 데이터를 일시적으로 쌓아 놓은 자료구조
- 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출(FIFO) 구조
- 큐에 데이터를 넣는 작업을 인큐(enqueue), 
데이터를 꺼내는 작업을 디큐(dequeue), 
데이터를 꺼내는 쪽을 프런트(front),
데이터를 넣는 쪽을 리어(rear) 라고 함
- 배열로 큐 만들기
```java
public class IntQueue {
	private int max; // 큐의 용량. 배열 que에  저장할 수 있는 최대 요소의 개수와 같음
	private int front; // 첫 번째 요소 커서
	private int rear; // 마지막 요소 커서
	private int num; // 현재 데이터 수
	private int[] que; // 큐 본체 : 큐로 사용할 배열
	
	// 실행 시 예외  : 큐가 비어있음
	public class EmptyIntQueueException extends RuntimeException{
		public EmptyIntQueueException() {}
	}
	
	
	// 실행 시 예외 : 큐가 가득 참
	public class OverflowIntQueueException extends RuntimeException {
		public OverflowIntQueueException() {}
	}
	
	// 생성자
	public IntQueue(int capacity) {
		num = front = rear = 0;
		max = capacity;
		try {
			que = new int[max]; // 큐 본체용 배열을 생성
		} catch (OutOfMemoryError e) { // 생성할 수 없음
			max = 0;
		}
	}
	
	// 큐에 데이터를 인큐 (데이터를 넣는 작업)
	public int enque(int x) throws OverflowIntQueueException{
		if (num>=max) {// 큐가 가득 차서 인큐할 수 없는 상태
			throw new OverflowIntQueueException(); // 예외 발생
		}
		
		que[rear++] = x;
		num++;
		
		if (rear == max) { // 최대 용량의 값과 같아질 경우 rear를 배열의 처음인 0으로 변경해야 함
			rear = 0;
		}
		return x;
	}
	
	// 데이터를 디큐(데이터를 꺼내는 작업)
	public int deque() throws EmptyIntQueueException {
		if (num <= 0) {
			throw new EmptyIntQueueException(); // 큐가 비어있는 상태
		}
		
		int x = que[front++];
		num--;
		
		if (front == max) { // front 값이 큐의 용량인 max와 같아지면 
			front = 0; // 프론트 값을 배열의 처음인 0으로 변경
		}
		return x;
	}
	
}
```